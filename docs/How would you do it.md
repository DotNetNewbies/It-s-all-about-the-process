
Ok, this document will be all about how I would approach my job as a senior  
software engineer (which I am).  

The following are just two of the myriad job offers I receive every day. These  
jobs are typical in their "required skills", I did not single them out for  
anything save that their job description was a little better than most as they  
contain a bit more detail as to what the job actually entails.  

Job Role: Senior .NET Developer

- Experience of leading team in all aspects of .NET

- Experience of AGILE methodology

- Must have strong communication skills

- Experience in onshore offshore communication 

- Experience in DOT NET CORE , C#, MVC, jQuery, Javascript

- Adaptable and quick in terms of changing situations.

- Hands on working experience in designing, solutioning and leading distributed  
  technologies like .NET, JavaScript, jQuery, linQ, etc

- Knowledge of Mulesoft API will be a bonus

- Confident and independent                    

- Experienced in SAFE, Scrum AGILE methodologies

- Vast experience in Design and requirement elicitation.

- Experienced .NET resource with Tech Leading experience (MUST)

- Should be experienced of handling offshore team and guide the team from  
  Technical standpoint.

- Communicate issues/risks/status to project stakeholders throughout the  
  engagement 

- Execute various phases of software development life cycle such as analysis,  
  design, technical writing, implementation, testing and deployment            

- Prepare requirement understanding document, test execution and defects  
  management           

- Providing subject matter expertise and technical guidance to the team

- Review Code and Test results of the team.  

### Summary of the "Senior .NET Developer" role:  

- Must be not only a developer, but must be a Team/technical (MUST) Lead  
- Familiar with Agile (which one?) - oh, wait, with SAFE Agile.
- Work with offshore teams (might need to be multi-lingual, certainly will be  
  working odd hours, not the standard 9-5)  
- Must be familiar with the following languages:  
  - C#  
    - ASP.NET's MVC (is that with Blazor or not? And which ASP.NET? Full  
      Framework, Core, if Core, which one? 3.1, 5.0, 6.0?)  
  - JQuery (javascript)
    - Implies front-end work, thus must also know CSS, probably Bootstrap.
      - OK, which version of Bootstrap? 3, maybe 4, how about 5?
  - javascript in general (so I guess no Blazor)  
- Mulesoft? It's an integration platform. So you also need to be:  
  - a Functional programmer (in addition to OOP)
    - Know the DataWeave language for Mulesoft integrations  
      Which language is used for MuleSoft? From their docs:  
      "DataWeave is a functional language used in Mule applications to perform  
      data transformations. Before you begin to use DataWeave to code your own  
      powerful and complex data transformations, you must understand the basic  
      concepts of programming and the core features of functional programming  
      languages."  
- Not only writing code, must be able to interface with stakeholders concerning  
  risks/status/issues as the project develops. (hint: This is the job of the PM)  
- Manage all phases of the SDLC (wait, what!?):  
  - Analysis (Job of the Business Analyst)
  - Design (Job of the Systems Architect)  
  - Technical writing (Technical document writer)  
  - implementation (NOW I get to write C# code)
  - Testing (Job of the QA specialist)  
  - Deployment (Job of the DevOps folks)  
  - Document all phases of the project (Tech writer again):
    - How to use the application
    - How to test the application
    - How to manage and alleviate defects in the application  
- Be the onsite technical lead to teach and provide guidance to the rest of the  
  team.
- Be the Development Manager to perform code reviews  
- Be the QA manager to perform test reviews.  

In short, the above summary requires that I be an ***expert*** in the following:  
- Developer (OOP and Functional, multi-lingual e.g. C#, javascript, DataWeave)  
- Team Lead
- Technical Lead (Systems Architect)  
- Project Manager
- Business Analyst  
- Technical writer  
- QA tester  
- QA manager  
- DevOps engineer  
- Cloud specialist (why use SAAS integration if not in the cloud?)  

In other words, I just hit ***TEN different, full-time, career-level*** job  
descriptions, each one of which I am to be something of an expert, certainly  
competent to perform.  

As I see it, should I wish to perform my job in keeping with my *very* high  
standards, my so-called "work-life balance" just went out the window for  
multiple reasons (think off-shore time zones and emerging "emergencies"), I  
will be *constantly* trying to keep up with 10 different fields of endeavour,  
I must constantly provide training to my peers, etc. etc. etc.  
And all for the lofty salary of...67K. Yep, sixty-seven thousand dollars a year.  

<hr>  

Position: .NET Developer

- Strong fundamentals including an understanding of data structures, concurrent  
  programming, and design patterns.

- Min 10+ years’ experience with .Net Technologies – Asp.Net, Console based App,  
  PowerShell & Web API Rest Services.

- Min 10+ years’ experience in the web development process (Design, Development,  
  and deployment) across the UI stack covering HTML5, CSS3, JavaScript (ES6),  
  and JavaScript/jQuery to develop user-friendly interfaces and dashboards.

- Should have good understanding of repository tool like GIT and DB deployment  
  tool like Liquibase.

- Should have good understanding of project management and issues tracking tool  
  like Odyssey Confluence and JIRA.

- Should have hands-on on designing web architecture.

- Should have excellent Oracle PL/SQL Programming, Indexing and Performance  
  tuning, Partitions understanding with very good Data Analysis skill.

- Preferable to have good understanding of IB reference data and transactional  
  (e.g., trade life cycle) data

- Should have good understanding of Control-M Scheduling tool.

- You are ambitious, dedicated, hardworking and can work on own initiative  
  whilst also working collaboratively and deliver on time with a high level of  
  integrity, sense of urgency, attention to -detail and quality standards.

- Ability to transform customer requirements into a workable design at the  
  functional and/or technical levels.

- Excellent problem-solving skills.

- Should have good communication skills for very frequent interaction with  
  business and production support team daily.Database knowledge
 
### Summary of the "Senior .NET Developer" role:  
- Must know what "IB" stands for (Investment Banking)  
- Must understand the following basics of computer science:
  - data structures
  - concurrent programming (a specialization)
  - design patterns.  
- Must have ***10 years*** .NET experience? Wait, what? 10 *years* experience  
  with which kind of .NET? Full Framework? MS stopped dev on that 3 years ago.  
  Core? OK, which one? There are ***major*** changes between 3.1, 5 and 6,  
  4 *language* changes that I am aware of so...10 years experience? Clarify!  
- 10 years not only as an algorithmic developer, but now, also 10 years with  
  all the major ***web*** technologies as well e.g. 
  - HTML 5
  - CSS 3
  - javascript
  - JQuery
  All of those imply that I must also be a web designer aka an artist aka a UX  
  specialist! Also, slipped in there was "(Design, Development and...deployment)  
  It's that last one that's the kicker - I am also to be a web deployment  
  specialist. OK, which environment? Kestrel? IIS? Apache? Not specified and,  
  this is the job of DevOps, NOT the developer!    
- Repository management e.g. Git
- Deployment management! "Liquibase"? Never heard of it!  
- Good understanding of project management and issue tracking tools like  
  "Odyssey Confluence" (never heard of it) and JIRA - great for issue tracking  
  but is usually not plugged into the rest of the development process.  
- Oracle PL/SQL skills and be able to tune queries (hint: That's the DBA's job)  
- Good knowledge of international banking procedures, reference data and  
  transactional data (another specialty), should be the purview of the BA.  
- Understanding of "Control-M Scheduling tool" - never heard of it.  
- You are ambitious, dedicated, hardworking and can work on own initiative  
  whilst also working collaboratively and deliver on time with a high level of  
  integrity, sense of urgency, attention to -detail and quality standards.  
  aka "Gung-Ho!". Deliver "on time"? See the imponderables.  
- Transform customer requirements into workable design. Hint: This is the SA's  
  and the BA's job!
- Excellent problem-solving skills. er, duh, that's what coding is all about!  
- Good communication skills so I can talk with the business and and "production  
  support (what's this)" team.  
    - So, now I'm also the PM and I'm supposed to be generating quality code in  
      between meetings, I presume.  

For this position, it pays oh so *much* better - 90K.  

<hr>  

In essence, the two above positions want me to be an expert in the *entire*  
*field* of computer science and fill *all* of the roles of the industry.  

There are so many things wrong with those postings that it's truly difficult to  
know where to begin. I suppose the best place is to begin by outlining all of  
the various roles these positions and others like them wish the employee to  
fill.  

Let's begin by stating that no one individual could possibly do all of the  
above well and still have a life of any sort. I would go so far as to say that  
no one could possibly do all the above jobs well, ***at all***. There is simply  
too much that needs to be covered, too much in-depth knowledge that is needed  
for each specialty and no time to acquire it all, let alone keep up with the  
ever-changing landscape that is "Computer Science".  

<hr>  

For the first order of business, let's define the various job roles that a  
successful development team will require.  

The first implication is that there will be a cross-functional team meaning that  
the folks will come from a wide variety of disciplines, each one a full-time  
career, not something one can do for an hour or two a week and be acceptably  
functional, let alone actually *good* at.  

So, first presumption is that this posting is for an *entire team*, not just a  
single developer.  

The major roles in any good software development team are these:  

[Development Team Roles][DevelopmentTeamRoles-Url]  

<hr>  

Leaders and Managers and the incredibly vast difference between them:  

[Leaders and Managers][LeadersAndManagers-Url]  

<hr>  

### WorkFlow Basics

The basics of any software solution can be summarized via the following basic  
types of activity:

<details>
  <summary>Problem statement</summary>  

This is the point where the stake holder realizes that a particular process  
has a flaw, is outdated, is no longer applicable in its current form, a new  
process is required, etc. This becomes "the problem".  

An example might be: "We want to sell books online".  

Now, having stated that particular goal, which is quite vague and rather  
nebulous, we need to apply some filtering and combing to the "napkin" and move  
from a place of vagueness to one of precise definition. How do we do that?  

By first outlining, in as much detail as possible and reasonable, the current  
environment. This gives all participants a common starting point to reference  
during the conversations that follow.  

Following that, define, in as simple as terms as possible, the deficiencies  
within said current environment.  

NOTE: This is NOT the place for "the software should..." statements. We, the  
engineers, are NOT INTERESTED in what users think "the answer" is. NOT THEIR  
JOB, that's OUR job as engineers. All we need from them is WHAT IS BROKEN,  
NOT how to fix it. As Henry Ford once said, "If I gave my customers what they  
wanted, I'd be breeding faster horses".

</details>

<details>
  <summary>Business Analysis</summary>

Because most stake holders are not engineering-oriented, actually _stating_  
the problem in terms that will make it solvable is, at best, problematic.  

Therefore, it is optimal that the stake holder meet with a person (or persons)  
that is/are familiar with the business as a whole but can think in terms of  
"process"and review "the problem" and break it down into manageable, stateable  
pieces. In short, assist the stake holder in converting the often-vaguely  
worded problem into a clearly defined set of problem statements that  
clearly and completely outline and define the deficiency.

In other words, the business analysis answers the question: "What to we need  
in order to solve the problem?".  

In the case of "sell books online", some of the pieces needed would be:
- inventory management
- search capability
- purchasing mechanism
- member management

The problem(s) is/are discussed and examined multiple times until an acceptable  
proposal is determined which answers that question of "what do we need...".  

</details>  

<details>
  <summary>Design Process</summary>  

The goal is to create a logically related set of requirements that allow  
the user to satisfy an objective.  

The design elements are usually generated by the counter-part of the  
Business Analyst (someone that knows the business but can speak a little "tech"  
as necessary), a person known as a "System Architect" (different from a "systems  
analyst" - a person that is responsible for hardware).  

The System Architect (SA) is a person that is an engineer that knows how to  
speak a little "business". Between the Business Analyst (BA) and the SA, the  
now clearly defined problem statements can be broken down into engineering  
pieces - the requirements that can be turned over to various team leads for  
further analysis.  

The design elements for the aforementioned online bookstore inventory  
management objective might be:
- User Interface
- Program API
- Middleware
- Persistence  

All the items are focused on "solving" the "inventory management" problem.  

</details>  

<details>
  <summary>Functionality Group</summary>  

A functionality group is a set of logically related requirements that allow the  
user to satisfy an objective.  

Functionality groups can (partially) be defined in terms of "acceptance tests"  
whereby the BA will generate one or more scenarios (Given...When...Then) such  
that a specified starting point is established, actions are applied and the  
desired result is noted. The language of choice for features is Gherkin.  

A functionality group of the "purchasing mechanism" might be all of the  
necessary steps and functions to implement an online shopping cart.  

The corresponding "features" will be the acceptance tests that prove, to the  
user and stake holders, that the engineers "got it right".  

</details>  

<details>
  <summary>Requirements</summary>

A requirement is a capability that a solution must possess to ultimately satisfy  
a feature. A requirement is a statement of an algorithm in that it is a single  
responsibility-oriented statement that describes a single function or activity.  

Requests for functionality of the aforementioned shopping cart might be:
- Member be able to add a book to the cart
- Member be able to remove a book from the cart
- Member be able to view all items currently in the cart
- Member be able to initiate check-out of the selected items for purchase.  

Each of the above will have an associated requirement that states how the  
functionality should be implemented e.g. "Add a book to the cart" will generate  
multiple requirements, each focusing on a single aspect of the functionality  
item.  

Such things as UX design, database access, how the cart should be stored, how  
the cart should be maintained whilst the user is modifying it, etc. All will be  
requirements in their own right.  

</details>

<details>
  <summary>Project Management and Tasking</summary>

Now that the requirements have been clearly defined and a method of  
validating the code which addresses each requirement has been determined,  
tasks must be created which define the work necessary to implement the  
requirements and, as necessary, implement the corresponding acceptance  
tests.  

An example might be to create all the necessary steps which will implement the  
"add a book to the shopping cart" requirement:
- Open a connection to the persistence store
- Transmit the book information to the persistence store
- Close the connection

</details>

<details>
  <summary>Work Items</summary>

Once the tasks have been determined and assigned to an engineer, each task may  
be broken down into one or more work items which will be implemented by an  
engineer.  

Each work item should focus on a single activity which is clearly defined,  
narrow in scope and generally adheres to the principles of SOLID (mainly  
the work item should focus on a single accomplishment to be implemented).  

As necessary, create the various steps which will satisfy each task, e.g.
for "open a connection to the persistence store", one might:
- verify that the shopping cart has at least one item
- verify that the persistence store is available
- Create the connection
- Fill in the necessary information for the "add"
- Transmit the information
- Acquire a response indicating success or failure of the "add".
- Close the connection.  

</details>

<details>
  <summary>Code Implementation and review</summary>

As each work item is implemented by an engineer, the result should be  
continuously checked into a code repository to prevent accidental loss and  
provide a history of development.  

Normally this will be done by creating a "work item" branch off of the  
"vNext" or "Development" branch which serves as the repository for all  
things "next version". Once the engineer is satisfied that the implementation  
of the work item is complete (meaning that the code and associated unit tests  
pass), the implementation should be offered up for code review by the  
engineers' peers and the implementation run through the acceptance tests. The  
review should be a human process, however, the acceptance tests can be a  
function of checking the code in for review as desired.  

</details>

<details>
  <summary>Merge to Development</summary>  

Once an implementation is reviewed and passes said review, the code should be  
sent to a "gatekeeper" who will then merge the code into the development code  
stream based on the implemented workflow.  

</details>

<details>
  <summary>Merge to QA</summary>  

Once all work items associated with a task are complete and all tasks  
associated with a selected mde are complete, the gatekeeper should  
release the implementations for testing. Given that all unit tests **must**  
pass and all acceptance tests **must** pass, all that remains is for the  
Project Manager to obtain input from the QA users concerning usability and  
correct functionality. There is nothing that says the unit/acceptance tests  
are actually _correct_, just that the implementation meets the required  
criteria of the tests themselves. Only a user can determine if the result  
actually solves the problem.  

</details>  

<details>
  <summary>Merge to Production</summary>  

Once QA has returned a "pass" on the mde, the gatekeeper can release it for  
production.  

</details>  

<details>
  <summary>Notes</summary>  

- It should be understood that "Merge to QA" and "Merge to Production"  
  means that only the _code_ is merged into the appropriate branch. The  
  _binaries_ can be forwarded _as-is_ to QA and even production -  
  this removes the potential for the "it works on _my_ machine" problems given  
  that the implementation that is reviewed by the engineers, that is tested by  
  QA and ultimately released into production can _and should_ be the _same_  
  binary. This removes the chances for contamination and configuration problems.  

- It should also be understood that all the steps do **NOT** need to be  
  accomplished in toto at the beginning of the project.  
  There is no harm whatsoever in breaking the entire process  
  into manageable pieces rather than the traditional "waterfall"  
  approach. Using smaller pieces allows for flexibility in design and  
  resulting implementation as well as reaction to outside influence.  

</details>
<br/>  

It should be clear at this point that the majority of the work involved in  
implementing a software solution is mainly in first defining, then breaking  
down the problem into manageable chunks.  

We first get a statement of the problem in general terms, then rely on one or  
more experts to define the problem completely and do so in terms that all  
participants in the solution can both understand and agree upon, aka "define  
the problem domain".  

Once the problem space has been completely defined, it remains only to carve  
it up into smaller and smaller units of implementation until each facet of the  
solution is bound by the notion of single responsibility. Each implemented  
piece is completely defined, tested and given a means of basic automatic  
acceptance.  

The engineer comes in rather late to the process, not until the tasks have been  
determined and project management has organized said tasks into some sort of  
deliverable flow. Once the tasks are defined, then and only then do the  
engineers in the trenches get involved and their process is to examine each  
task to ensure it meets the "single responsibility" pattern, then create the  
appropriate work items in accordance with their own implementation process and  
then write the code.  

The rest is maintenance and workflow, most, if not all, of which should be a  
very non-intrusive, automated process. The engineer should be able to focus on  
a single function - writing excellent code. After all, all of this preparation,  
definition, classification and organization is in place for the sole purpose  
of providing the engineer with as painless and easy an environment to work in  
as possible. Why? Because it's the engineer that is providing the deliverable,  
**everything else** is in support of this goal therefore, it is up to the  
non-engineering portion of the team to make this as non-intrusive as possible  
so that the engineer can focus on that one thing - writing excellent code!  

This is _not_ to say that the non-engineers jobs are less important, just the  
opposite in fact! There is an old, old acronym in the computing world: "GIGO".  
It means "Garbage In, Garbage Out". Another way of saying that is "If one  
starts with crappy requirements, one will receive crappy code.". It is  
absolutely _vital_ that the steps leading up to implementing the work items be  
accomplished with a great deal of thought and care to attention to detail so  
that the engineer knows _exactly_ what needs to be created.  

<hr>  

[LeadersAndManagers-Url]: ./Define%20Leader%20and%20Define%20Manager.md  
[DevelopmentTeamRoles-Url]: ./WorkFlowRoles.md  
